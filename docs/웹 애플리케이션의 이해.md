# 웹 애플리케이션의 이해

## 웹 서버,웹 애플리케이션 서버
<details>
<summary><b>웹 서버(Web Server)</b></summary>  

<div markdown="1">  

- **HTTP 기반으로 동작**
- **정적 리소스 제공, 기타 부가기능**
- **정적(파일) HTML, CSS, JS, 이미지, 영상**
- **예) NGINX, APACHE**

</div>
</details>  

<details>
<summary><b>웹 애플리케이션 서버(WAS - Web Application Server)</b></summary>  

<div markdown="1">  
  
- **HTTP 기반으로 동작**
    - **웹 서버 기능 포함 + (정적 리소스 제공 가능)**
    - **프로그램 코드를 실행해서 애플리케이션 로직 수행**
        - **동적 HTML, HTTP API(JSON)**
        - **서블릿, JSP, 스프링 MVC**
    - **예) 톰캣(Tomcat) Jetty, Undertow**

</div>
</details>

<details>
<summary><b>웹 서버 ≠ 웹 애플리케이션 서버의 차이</b></summary>  

<div markdown="1">  
  
- **웹 서버는 정적 리소스(파일), WAS는 애플리케이션 로직**
- **사실은 둘의 용어도 경계가 모호하다고 한다.**
    - **웹 서버도 프로그램을 실행하는 기능을 포함하기도 함**
    - **웹 애플리케이션 서버도 웹 서버의 기능을 제공**
- **자바는 서블릿 컨테이너 기능을 제공하면 WAS**
    - **서블릿 없이 자바코드를 실행하는 서버 프레임워크도 있다고 한다.**
- **WAS는 애플리케이션 코드를 실행하는데 더 특화**
    
**크게 보면 웹 서버 = 정적리소스 WAS = 애플리케이션 로직을 실행하는 서버로 이해하면 된다.**

</div>
</details>

<details>
<summary><b>웹 시스템 구성 - WAS, DB</b></summary>  

<div markdown="1">  
  
- **WAS, DB만으로 시스템 구성 가능**
    - **WAS는 정적 리소스, 애플리케이션 로직 모두 제공**
        - **하지만 WAS 하나만 가지고 운영하면 WAS가 너무 많은 역활을 담당, 서버 과부화 우려가 있다.**
        - **값 비싼 애플리케이션 로직이 정적 리소스 때문에 수행이 어려울 수 있다.**
        - **WAS 장애시 오류 화면도 노출 불가능**
    
**크게 보면 웹 서버 = 정적리소스 WAS = 애플리케이션 로직을 실행하는 서버로 이해하면 된다.**

</div>
</details>

<details>
<summary><b>웹 시스템 구성 - WEB, WAS, DB</b></summary>  

<div markdown="1">  
  
- **정적 리소스는 웹 서버가 처리**
    - **웹 서버는 애플리케이션 로직 같은 동적인 처리가 필요하면 WAS에 요청을 위임**
    - **WAS는 중요한 애플리케이션 로직 처리 전담**
    
    ![image](https://user-images.githubusercontent.com/106207558/216787061-94e318a1-41be-4607-9a67-8a710d9234e8.png)
    
    - **이 처럼 구성을 하면 효율적인 리소스 관리 가능**
        - **정적 리소스가 많이 사용되면 Web 서버 증설을 하고**
        - **애플리케이션 리소스가 많이 사용되면 WAS를 증설 하면 된다.**
    - **정적 리소스만 제공하는 웹 서버는 잘 죽지 않음**
    - **애플리케이션 로직이 동작하는 동안 WAS서버는 잘 죽음**
    - **WAS, DB장애시 WEB 서버가 오류 화면 제공 가능**
    - **API 만 제공하는 경우 WEB서버가 없이 WAS서버가 구축해도 된다.**

</div>
</details>
  
## 서블릿

<details>
<summary><b>서블릿의 특징</b></summary>  

<div markdown="1">  
  
**HTML Form 데이터 전송**

**아래와 같이 POST로 데이터를 전송하면 웹브라우저가 요청 HTTP 메시지를 만들어서 서버로 전송을 한다.**
![image](https://user-images.githubusercontent.com/106207558/216807048-3cad6718-f752-438d-8607-f9c6c85b7a44.png)  

**만약에 웹 애플리케이션 서버를 처음부터 끝까지 전부 구현 해야 한다면 아래와 같이 모든 부분을 구현해야 하는데 서블릿이 초록색 부분을 제외한 모든 부분을 자동화 해준다.**
  
  ![image](https://user-images.githubusercontent.com/106207558/216807063-4b515656-8aad-4b18-ad32-8d9735bb3747.png)
- **urlPatterns(/hello)의 URL이 호출되면 서블릿 코드가 실행**
- **HTTP  요청 정보를 편리하게 사용할 수 있는 HttpServletRequet**
- **HTTP 응답 정보를 편리하게 제공할 수 있는 HttpServletResponse**
- **개발자는 HTTP 스펙을 매우 편리하게 사용**
</div>
</details>

<details>
<summary><b>서블릿 ) HTTP 요청, 응답 흐름</b></summary>  

<div markdown="1">  
  
- **HTTP 요청시**
    - **WAS는 Request, Response 객체를 새로 만들어서 서블릿 객체 호출**
    - **개발자는 Request 객체에서 HTTP 요청 정보를 편리하게 꺼내서 사용**
    - **개발자는 Response 객체에 HTTP 응답 정보를 편리하게 입력**
    - **WAS는 Response 객체에 담겨있는 내용으로 HTTP 응답 정보를 생성**
</div>
</details>

<details>
<summary><b>서블릿 컨테이너</b></summary>  

<div markdown="1">  
  
- **톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 함**
- **서블릿 컨테이너는 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기 관리**
- **서블릿 객체는 싱글톤으로 관리**
    - **고객의 요청이 올 때 마다 계속 객체를 생성하는 것은 비효율**
    - **최초 로딩 시점에 서블릿 객체를 미리 만들어두고 재활용**
    - **모든 고객 요청은 동일한 서블릿 객체 인스턴스에 접근**
    - **공유 변수 사용 주의**
    - **서블릿 컨테이너 종료시 함께 종료**
- **JSP도 서블릿으로 변환 되어서 사용**
- **동시 요청을 위한 멀티 쓰레드 처리 지원**
</div>
</details>

## 동시 요청 - 멀티 쓰레드 

![image](https://user-images.githubusercontent.com/106207558/216807122-ea671b6b-3d50-457a-ac34-d3504b4f9279.png)  

**서블릿 객체는 쓰레드가 호출 한다.**  

<details>
<summary><b>쓰레드</b></summary>  

<div markdown="1">  
  
- **애플리케이션 코드를 하나하나 순차적으로 실행하는 것은 쓰레드**
- **자바 메인 메서드를 처음 실행하면 main이라는 이름의 쓰레드가 실행**
- **쓰레드가 없다면 자바 애플리케이션 실행이 불가**
- **쓰레드는 한번에 하나의 코드 라인만 수행**
- **동시 처리가 필요하면 쓰레드를 추가로 생성**
</div>
</details>

<details>
<summary><b>단일 요청 - 쓰레드 하나 사용 </b></summary>  

<div markdown="1">  
  
![image](https://user-images.githubusercontent.com/106207558/216807215-08d889d6-7d3f-4305-a532-ef66b3ace6e0.png)  
**요청이 오면 쓰레드 할당 → 응답 → 휴식**  
![image](https://user-images.githubusercontent.com/106207558/216807231-04debacf-a936-4254-a02c-4388611fa24e.png)

</div>
</details>

<details>
<summary><b>다중 요청 - 멀티쓰레드(쓰레드 풀)</b></summary>  

<div markdown="1">  
  
**쓰레드 하나 사용**   
![image](https://user-images.githubusercontent.com/106207558/216807295-ce32bbd1-89c4-4e02-bba3-fe8fea59ae61.png)  

**1번이 쓰레드를 어떤 이유에서 요청 처리가 지연되고 있을 때 2번이 요청을 하면 수행자체를 하지 못하고 Timeout이 생겨 오류가 일어나게 된다.**

**그래서 요청 마다 쓰레드 생성**

![image](https://user-images.githubusercontent.com/106207558/216807312-2813c57e-7514-4dae-aa9d-ec303ff48189.png)  

**요청마다 쓰레드 생성**

**장단점**

- **장점**
    - **동시 요청을 처리할 수 있다.**
    - **리소스(CPU, 메모리)가 허용할 때 까지 처리가능**
    - **하나의 쓰레드가 지연 되어도, 너머지 쓰레드는 정상 동작한다.**
- **단점**
    - **쓰레드는 생성 비용이 매우 비싸다.**
        - **고객의 요청이 올 때 마다 쓰레드를 생성하면, 응답 속도가 늦어진다.**
    - **쓰레드는 컨텍스트 스위칭 비용이 발생한다.**
    - **쓰레드 생성에 제한이 없다.**
        - **고객 요청이 너무 많이 오면 CPU, 메모리 임계점을 넘어서 서버가 죽을 수 있다.**

**위와 같은 문제를 해결 하기 위해 쓰레드 풀이라는 것을 사용한다.**

**요청이 오면 쓰레드 풀에게 놀고 있는 쓰레드를 요청 →  쓰레드풀에서 쓰레드를 가져다 사용 → 쓰레드 다 쓰면 쓰레드를 죽이는 것이 아니라 쓰레드를 쓰레드 풀에 반납**  

![image](https://user-images.githubusercontent.com/106207558/216807364-b6cbced4-760f-4774-9524-319d5afad4f4.png)  
**위 그림과 같이 쓰레드 풀에 200개의 스레드가 생성되어 있을 때 201개 이상의 동시요청이 온다면 설정에 따르 다르지만 요청을 대기 시키거나, 거부 할 수 있다.**

**정리** 

**요청 마다 쓰레드 생성의 단점을 보완**

- **특징**
    - **필요한 쓰레드를 쓰레드 풀에 보관하고 관리**
    - **쓰레드 풀에 생성 가능한 쓰레드의 최대치를 관리, 톰캣은 최대 200개 기본 설정(변경 가능)**
- **사용**
    - **쓰레드가 필요하면, 이미 생성되어 있는 쓰레드를 쓰레드 풀에서 꺼내서 사용한다.**
    - **사용을 종료하면 쓰레드 풀에 해당 쓰레드를 반납한다.**
    - **최대 쓰레드가 모두 사용중이어서 쓰레드 풀에 쓰레드가 없다면?**
        - **기다리는 요청을 거절하거나, 특정 숫자만큼 대기하도록 설정할 수 있다.**

- **장점**
    - **쓰레드가 미리 생성되어 있으므로, 쓰레드를 생성하고 종료하는 비용(CPU)이 절약되고),, 응답 시간이 빠르다.**
    - **생성 가능한 쓰레드의 최대치가 있으므로 너무 많은 요청이 들어와도 기존 요청은 안전하게 처리할 수 있다.**

**실무 팁** 

- **WAS의 주요 튜닝 포인트는 최대 쓰레드(max thread) 수이다.**
- **이 값을 너무 낮게 설정하면?**
    - **동시 요청이 많으면 서버 리소스는 여유롭지만, 클라이언트는 금방 응답 지연**
- **이 값을 너무 높게 설정하면?**
    - **동시 요청이 많으면 CPU, 메모리 리소스 임계점 초과로 다운**
- **장애 발생시 ?**
    - **클라우드면 일단 서버를 늘리고, 이후에 튜닝**
    - **클라우드가 아니면 열심히 튜닝**

**쓰레드 풀의 적정 숫자**

- **애플리케이션의 로직의 복잡도, CPU, 메모리, IO리소스 상황에 따라 모두 다름**
- **성능 테스트**
    - **최대한 실제 서비스와 유사하게 성능 테스트 시도**
    - **툴 : 아파치 ab, 제이미터, nGrinde(네이버 오픈 소스)**

**핵심 = WAS의 멀티 쓰레드 지원**

- **멀티 쓰레드에 대한 부분은 WAS가 처리**
- **개발자가 멀티 쓰레드 관련 코드를 신경쓰지 않아도 됨**
- **개발자는 마치 싱글 쓰레드 프로그래밍을 하듯이 편리하게 소스 코드를 개발**
- **멀티 쓰레드 환경이므로 싱글톤 객체(서블릿, 스프링 빈)는 주의해서 사용**

</div>
</details>

## HTML, HTTP API, CSR, SSR

<details>
<summary><b>HTML, HTTP API, CSR, SSR</b></summary>  

<div markdown="1">  
  
**정적 리소스**

- **고정된 HTML파일, CSS, JS, 이미지, 영상 등을 제공**
- **주로 웹 브라우저**

**HTML 페이지(동적)**

- **동적으로 필요한 HTML 파일을 생성해서 전달**
- **웹 브라우저:HTML 해석**

**HTTP API**

- **HTML이 아니라 데이터 전달**
- **주로 JSON 형식 사용**
    - **JSON형태로 데이터 통신**
- **다양한 시스템에서 호출**
- **데이터만 주고 받음, UI화면이 필요하면, 클라이언트가 별도 처리**
    - **웹 클라이언트(아이폰, 안드로이드, PC 앱)**
    - **웹 브라우저에서 자바스크립트를 통한 HTTP API 호출**
    - **React, Vue.js 같은 웹 클라이언트**
- **웹, 앱 클라이언트, 서버 to 서버**
    - **주문서버 → 결제 서버**
    - **기업간 데이터 통신**  
    ![image](https://user-images.githubusercontent.com/106207558/216807473-ee0ae597-5ae8-431b-8d29-e120f3b97f31.png)  
    
**서버 사이드 렌더링, 클라이언트 사이드 렌더링**
- **SSR - 서버 사이드 렌더링**
    - **주로 정적인 화면에 사용**
    - **관련기술 : JSP, 타임리프 → 백엔드 개발자**
    - **서베에서 최종 HTML을 생성해서 클라이언트에 전달**
![image](https://user-images.githubusercontent.com/106207558/216807720-88538953-0111-436e-a887-e77ffdc87bca.png)  
- **CSR - 클라이언트 사이드 렌더링**
    - **HTML 결과를 자바스크립트를 사용해 웹 브라우저에서 동적으로 생성해서 적용**
    - **주로 동적인 화면에 사용, 웹 환경을 마치 앱 처럼 필요한 부분부분 변경할 수 있음**
    - **예) 구글 지도, Gmail, 구글 캘린더**
    - **관련기술 : React, Vue.js → 웹 프론트엔드 개발자**  
    
![image](https://user-images.githubusercontent.com/106207558/216807736-ddda12c1-5848-4174-9433-d7e77ffa726f.png)  
- **참고**
    - **React, Vue.js CSR + SSR 동시에 지원하는 앱 프레임워크도 있다.**
    - **SSR을 사용하더라도, 자바스크립트를 사용해서 화면 일부를 동적으로 변경 가능**

**백엔드 개발자 입장에서 UI기술**

- **백엔드 - 서버 사이드 렌더링 기술**
    - **JSP, 타임리프**
    - **화면이 정적이고, 복잡하지 않을 때 사용**
    - **백엔드 개발자는 서버 사이드 렌더링 기술 학습 필수**
- **웹 프론트엔드 - 클라이언트 사이드 렌더링 기술**
    - **React, Vue.js**
    - **복잡하고 동적인 UI사용**
    - **웹 프론트엔드 개발자의 전문 분야**

</div>
</details>

## 자바 백엔드 웹 기술

- **스프링 부트**
    - **스프링 부트는 서버를 내장**
    - **과거에는 서버에 WAS를 직접 설치하고, 소스는 War파일을 만들어서 설치한 WAS에 배포**
    - **스프링 부트는 빌드 결과를(Jar)에 WAS 서버 포함 → 빌드 배포 단순화**

- **스프링 웹 기술의 분화**
    - **Web Servlet - Spring MVC**
    - **Web Reactive - Spring WebFlux 최신기술**
        - **특징**
            - **비동기 넌 플러킹 처리**
            - **최소 쓰레드로 최소 성능 → 쓰레드 컨텍스트 스위칭 비용 효율화**
            - **함수형 스타일로 개발 → 동시처리 코드 효율화**
            - **서블릿 기술 사용 X**
        - **그런데**
            - **웹 플럭스는 기술적 난이도 매우 높음**
            - **아직은 RDB지원 부족**
            - **일반 MVC의 쓰레드 모델로 충분히 빠르다.**
            - **실무에서 아직 많이 사용하지 않는다고 함**
            
- **자바 뷰 템플릿 (HTML을 편리하게 생성하는 뷰 기능)**
    - **JSP**
        - **속도 느림, 기능 부족**
    - **프리마커(Freemarker), Velocitty(벨로시티)**
        - **속도 문제 해결, 다양한 기능 제공**
        - **단점 = 발전을 안함**
    - **타임리프(Thymeleaf)**
        - **내추럴 템플릿 : HTML의 모양을 유지하면서 뷰 템플릿 적용 가능**
        - **스프링 MVC와 강력한 기능 통합**
        - **최선의 선택, 단 성능은 프리마커, 벨로시티가 더 빠름**